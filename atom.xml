<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yugoal.github.io</id>
    <title>Gridea</title>
    <updated>2021-08-03T03:08:07.935Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yugoal.github.io"/>
    <link rel="self" href="https://yugoal.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yugoal.github.io/images/avatar.png</logo>
    <icon>https://yugoal.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[仿自如 App 裸眼 3D 效果]]></title>
        <id>https://yugoal.github.io/post/fang-zi-ru-app-luo-yan-3d-xiao-guo/</id>
        <link href="https://yugoal.github.io/post/fang-zi-ru-app-luo-yan-3d-xiao-guo/">
        </link>
        <updated>2021-08-03T02:36:14.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>获取手机重力传感器值</li>
</ol>
<pre><code class="language-java">public class GyroscopeManager implements SensorEventListener {

    // 将纳秒转化为秒
    private static final float NS2S = 1.0f / 1000000000.0f;

    private List&lt;XImageView&gt; list_views = new ArrayList&lt;&gt;();
    private SensorManager sensorManager;

    private long endTimestamp;
    private double angleX;
    private double angleY;

    //0到π/2
    private double maxAngle = Math.PI / 3;


    public void addView(XImageView xImageView) {
        if (xImageView != null &amp;&amp; !list_views.contains(xImageView)) {
            list_views.add(xImageView);
        }
    }

    public void register(Context context) {
        if (sensorManager == null) {
            sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
        }
        Sensor mSensor = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
        sensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_FASTEST);

        endTimestamp = 0;
        angleX = 0;
        angleY = 0;
    }

    public void unregister() {
        if (sensorManager != null) {
            sensorManager.unregisterListener(this);
            sensorManager = null;
        }
    }

    @Override
    public void onSensorChanged(SensorEvent event) {
        if (endTimestamp == 0) {
            endTimestamp = event.timestamp;
            return;
        }
        angleX += event.values[0] * (event.timestamp - endTimestamp) * NS2S;
        angleY += event.values[1] * (event.timestamp - endTimestamp) * NS2S;

        if (angleX &gt; maxAngle) {
            angleX = maxAngle;
        }
        if (angleX &lt; -maxAngle) {
            angleX = -maxAngle;
        }


        if (angleY &gt; maxAngle) {
            angleY = maxAngle;
        }
        if (angleY &lt; -maxAngle) {
            angleY = -maxAngle;
        }

        for (XImageView view : list_views) {
            if (view != null) {
                view.update(angleY / maxAngle, angleX / maxAngle);
            }
        }
        endTimestamp = event.timestamp;
    }

    @Override
    public void onAccuracyChanged(Sensor sensor, int accuracy) {

    }
}
</code></pre>
<ol start="2">
<li>根据传感器的值绘制图片</li>
</ol>
<pre><code class="language-java">public class XImageView extends ImageView {
    private static final String TAG = &quot;XImageView&quot;;
    private double scaleX;
    private double scaleY;
    private double scaleMaxY;
    private double scaleMaxX;
    private float lenX;
    private float lenY;
    private boolean isBG;
    private boolean isMiddle;
    private boolean isForeground;

    public XImageView(Context context) {
        super(context);
        init();
    }

    public void setBG(boolean BG) {
        isBG = BG;
    }

    public void setForeground(boolean foreground) {
        isForeground = foreground;
    }

    public void setMiddle(boolean middle) {
        isMiddle = middle;
    }

    public XImageView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public XImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private void init() {
        setScaleType(ScaleType.CENTER);
    }

    @Override
    public void setScaleType(ScaleType scaleType) {
        super.setScaleType(ScaleType.CENTER);
    }


    public void setGyroscopeManager(GyroscopeManager gyroscopeManager) {
        if (gyroscopeManager != null) {
            gyroscopeManager.addView(this);
        }
    }


    public void update(double scaleX, double scaleY) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        invalidate();
    }


    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int width = MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight();
        int height = MeasureSpec.getSize(heightMeasureSpec) - getPaddingTop() - getPaddingBottom();

        if (getDrawable() != null) {
            int drawableWidth = getDrawable().getIntrinsicWidth();
            int drawableHeight = getDrawable().getIntrinsicHeight();

            lenX = Math.abs((drawableWidth - width) * 0.5f);
            lenY = Math.abs((drawableHeight - height) * 0.5f);
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (getDrawable() == null || isInEditMode()) {
            super.onDraw(canvas);
            return;
        }

        if (isMiddle) {
            scaleX = 0;
            scaleY = 0;
        }
        if (isBG) {
            scaleX = -scaleX;
            scaleY = -scaleY;
        }
        Log.d(TAG, &quot;onDraw: &quot; + scaleY);
        float currentOffsetX = (float) (lenX * scaleX);
        float currentOffsetY = (float) (lenY * scaleY);
        canvas.save();
        canvas.translate(currentOffsetX, 0);
        canvas.translate(0, currentOffsetY);
        super.onDraw(canvas);
        canvas.restore();
    }
}
</code></pre>
<p>3.使用</p>
<pre><code class="language-java">  XImageView imageView1 = (XImageView) findViewById(R.id.iv1);
        XImageView imageView2 = (XImageView) findViewById(R.id.iv2);
        XImageView imageView3 = (XImageView) findViewById(R.id.iv3);


        imageView1.setGyroscopeManager(gyroscopeManager);
        imageView1.setMiddle(true);
        imageView2.setGyroscopeManager(gyroscopeManager);
        imageView2.setBG(true);
        imageView3.setGyroscopeManager(gyroscopeManager);
        imageView3.setForeground(true);
</code></pre>
<p><a href="https://github.com/WinterRunner/gyroscope">陀螺仪图片转动</a><br>
<a href="https://juejin.cn/post/6989227733410644005">自如裸眼3D原理</a>​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[App启动优化]]></title>
        <id>https://yugoal.github.io/post/app-qi-dong-you-hua/</id>
        <link href="https://yugoal.github.io/post/app-qi-dong-you-hua/">
        </link>
        <updated>2021-07-29T08:18:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="启动分类">启动分类</h1>
<ul>
<li>冷启动
<ul>
<li>耗时最多
<ul>
<li>Click Event-&gt;IPC-&gt;Process.start-&gt;ActivityThread-&gt;bindApplication-&gt;</li>
<li>LifeCycle-&gt;ViewRootImpl</li>
</ul>
</li>
</ul>
</li>
<li>热启动
<ul>
<li>最快
<ul>
<li>后台-&gt;前台</li>
</ul>
</li>
</ul>
</li>
<li>温启动<br>
- 较快<br>
- 重走生命周期LifeCycle</li>
</ul>
<h1 id="相关任务">相关任务</h1>
<ul>
<li>冷启动之前（系统任务，不能干预）</li>
<li>启动App</li>
<li>加载空白window</li>
<li>创建进程</li>
<li>随后任务
<ul>
<li>加载布局</li>
<li>布置屏幕</li>
<li>首页绘制</li>
</ul>
</li>
</ul>
<h1 id="优化方向">优化方向</h1>
<p>Application+LifeCycle</p>
<h1 id="优化方法">优化方法</h1>
<h3 id="1测量启动时间">1.测量启动时间</h3>
<h4 id="adb-命令线下使用-不够严谨">adb 命令（线下使用、不够严谨）</h4>
<ul>
<li>adb shell am start -W packagename/MainActivity</li>
</ul>
<h4 id="手动打点精确可带到线上">手动打点（精确，可带到线上）</h4>
<ul>
<li>通过在启动和 结束的地方埋点然后就行时间差值计算（采用Feed第一条数据，避免onWindowFoucsChanged 首帧时间误区，onWindowFoucsChanged 是绘制首帧的时间，并不是界面展示到用户面前的时间）</li>
</ul>
<h3 id="2优化分析工具">2.优化分析工具</h3>
<h4 id="traceview">traceview</h4>
<ul>
<li>使用方式
<ul>
<li>开始：Debug.startMethodTracing(&quot;报告文件名&quot;);</li>
<li>结束：Debug.stopMethodTracing();</li>
<li>生成文件地址：sd卡，Android/data/packagename/files/报告文件名</li>
</ul>
</li>
<li>优点<br>
- 图表显示数据内容详细全面</li>
<li>缺点<br>
- 运行时开销严重，App变慢，导致原本不会卡顿的地方变卡顿，带偏优化方向</li>
</ul>
<h4 id="systrace">systrace</h4>
<ul>
<li>结合Android内核数据，生成html报告</li>
<li>api18 以上使用</li>
<li>使用方式</li>
<li>优点
<ul>
<li>轻量级</li>
<li>反应cpu利用率</li>
<li>cputime与walltime区别
<ul>
<li>walltime代码执行时间</li>
<li>cputime代码消耗cpu时间（重点指标）</li>
<li>举例：锁冲突（一个不耗时的方法需要拿到锁才能执行，在等待锁的时候代码后停在那等待，这时候是没有消耗cpu的，这样就造成walltime时间变长）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3aop获取方法耗时">3.AOP获取方法耗时</h3>
<p>无侵入性</p>
<h4 id="aspectj使用">AspectJ使用</h4>
<h1 id="启动优化">启动优化</h1>
<p>开屏优化<br>
把空白window替换为App图标或启动页<br>
异步优化<br>
Application中的代码根据需求来使用多线程执行。<br>
线程池核心数量定义：Math.max(2,Math.min(CPU_COUNT-1,4))<br>
​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[5种方法完美解决android软键盘挡住输入框方法详解]]></title>
        <id>https://yugoal.github.io/post/5-chong-fang-fa-wan-mei-jie-jue-android-ruan-jian-pan-dang-zhu-shu-ru-kuang-fang-fa-xiang-jie/</id>
        <link href="https://yugoal.github.io/post/5-chong-fang-fa-wan-mei-jie-jue-android-ruan-jian-pan-dang-zhu-shu-ru-kuang-fang-fa-xiang-jie/">
        </link>
        <updated>2021-07-05T02:46:00.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1741756">5种方法完美解决android软键盘挡住输入框方法详解</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 屏幕适配方案]]></title>
        <id>https://yugoal.github.io/post/android-ping-mu-gua-pei-fang-an/</id>
        <link href="https://yugoal.github.io/post/android-ping-mu-gua-pei-fang-an/">
        </link>
        <updated>2021-05-11T15:04:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="官方dp的缺点">官方dp的缺点</h2>
<blockquote>
<p>px = dp * (dpi/160)</p>
</blockquote>
<blockquote>
<p>dpi= √ (宽^2 + 高^2) / 尺寸</p>
</blockquote>
<p>问题就出在dpi上面，各厂商并没有按照谷歌的标准走，就算分辨率宽高是标准的，但是手机尺寸各种各样，这样就导致dpi不符合标准，因为dpi不符合标准，所以dp就不太标准。</p>
<h2 id="适配方案">适配方案</h2>
<p>布局组件适配<br>
使用dp<br>
使用相对布局或线性布局<br>
使用warp_content,match_parent,权重<br>
使用minWidth,minHeight,lines等<br>
dimens使用<br>
布局适配（布局别名：同一个activity拥有多个布局时，可以通过values建立不同的文件夹，布局别名相同）<br>
代码适配<br>
今日头条方案：宽度像素/设计稿dpi求出density<br>
makexml生成不同分辨率方案</p>
<pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;

/**
 * Created by lenovo on 2016/12/2.
 */

public class MakeXml {
    // 生成地址 C盘layoutroot目录下
    private final static String rootPath = &quot;C:\\layoutroot\\values-{0}x{1}\\&quot;;

    /**
     * 设置基准分辨率
     * 一般标注按照多大的图标，这里我们就设置多大尺寸
     */
    private final static float dw = 720f;
    private final static float dh = 1280f;

    private final static String WTemplate = &quot;&lt;dimen name=\&quot;x{0}\&quot;&gt;{1}px&lt;/dimen&gt;\n&quot;;
    private final static String HTemplate = &quot;&lt;dimen name=\&quot;y{0}\&quot;&gt;{1}px&lt;/dimen&gt;\n&quot;;

    // 手机分辨率
    public static void main(String [] args){
        makeString(320, 480);
        makeString(480, 800);
        makeString(480, 854);
        makeString(540, 960);
        makeString(600, 1024);
        makeString(720, 1184);
        makeString(720, 1196);
        makeString(720, 1280);
        makeString(768, 1024);
        makeString(800, 1280);
        makeString(900, 1440);
        makeString(1080, 1812);
        makeString(1080, 1920);
        makeString(1440, 2560);

    }

    public static void makeString(int w, int h) {

        StringBuffer sb = new StringBuffer();
        sb.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\n&quot;);
        sb.append(&quot;&lt;resources&gt;&quot;);
        float cellw = w / dw;
        for (int i = 1; i &lt; dw; i++) {
            sb.append(WTemplate.replace(&quot;{0}&quot;, i + &quot;&quot;).replace(&quot;{1}&quot;, change(cellw * i) + &quot;&quot;));
        }
        sb.append(WTemplate.replace(&quot;{0}&quot;, &quot;720&quot;).replace(&quot;{1}&quot;, w + &quot;&quot;));
        sb.append(&quot;&lt;/resources&gt;&quot;);

        StringBuffer sb2 = new StringBuffer();
        sb2.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\n&quot;);
        sb2.append(&quot;&lt;resources&gt;&quot;);
        float cellh = h / dh;
        for (int i = 1; i &lt; dh; i++) {
            sb2.append(HTemplate.replace(&quot;{0}&quot;, i + &quot;&quot;).replace(&quot;{1}&quot;, change(cellh * i) + &quot;&quot;));
        }
        sb2.append(HTemplate.replace(&quot;{0}&quot;, &quot;1280&quot;).replace(&quot;{1}&quot;, h + &quot;&quot;));
        sb2.append(&quot;&lt;/resources&gt;&quot;);

        String path = rootPath.replace(&quot;{0}&quot;, h + &quot;&quot;).replace(&quot;{1}&quot;, w + &quot;&quot;);
        File rootFile = new File(path);
        if (!rootFile.exists()) {
            rootFile.mkdirs();
        }
        File layxFile = new File(path + &quot;lay_x.xml&quot;);
        File layyFile = new File(path + &quot;lay_y.xml&quot;);
        try {
            PrintWriter pw = new PrintWriter(new FileOutputStream(layxFile));
            pw.print(sb.toString());
            pw.close();
            pw = new PrintWriter(new FileOutputStream(layyFile));
            pw.print(sb2.toString());
            pw.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    public static float change(float a) {
        int temp = (int) (a * 100);
        return temp / 100f;
    }

}
</code></pre>
<h2 id="刘海屏">刘海屏</h2>
<p>查看各厂商文档<br>
​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[App黑白化代码实现]]></title>
        <id>https://yugoal.github.io/post/app-hei-bai-hua-dai-ma-shi-xian/</id>
        <link href="https://yugoal.github.io/post/app-hei-bai-hua-dai-ma-shi-xian/">
        </link>
        <updated>2021-04-06T02:51:44.000Z</updated>
        <content type="html"><![CDATA[<pre><code>public class BaseApp extends Application implements Application.ActivityLifecycleCallbacks{
    
    @Override
    public void onActivityCreated(@NonNull Activity activity, @Nullable Bundle savedInstanceState) {
        Paint paint = new Paint();
        ColorMatrix cm = new ColorMatrix();
        cm.setSaturation(0);//关键代码
        paint.setColorFilter(new ColorMatrixColorFilter(cm));
        activity.getWindow().getDecorView().setLayerType(View.LAYER_TYPE_HARDWARE, paint);
    }

    @Override
    public void onActivityStarted(@NonNull Activity activity) {

    }

    @Override
    public void onActivityResumed(@NonNull Activity activity) {

    }

    @Override
    public void onActivityPaused(@NonNull Activity activity) {

    }

    @Override
    public void onActivityStopped(@NonNull Activity activity) {

    }

    @Override
    public void onActivitySaveInstanceState(@NonNull Activity activity, @NonNull Bundle outState) {

    }

    @Override
    public void onActivityDestroyed(@NonNull Activity activity) {

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android与webview的js交互]]></title>
        <id>https://yugoal.github.io/post/android-yu-webview-de-js-jiao-hu/</id>
        <link href="https://yugoal.github.io/post/android-yu-webview-de-js-jiao-hu/">
        </link>
        <updated>2021-03-23T07:47:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="webview调用java方法">WebView调用Java方法</h2>
<ol>
<li>允许WebView加载js</li>
</ol>
<pre><code class="language-java">webSettings.setJavaScriptEnabled(true);
</code></pre>
<ol start="2">
<li>编写js接口类</li>
</ol>
<pre><code class="language-java">public class WebAppInterface {
        @JavascriptInterface
        public String getUrl() {
            return photo;
        }
    }
</code></pre>
<ol start="3">
<li>Webview添加js接口</li>
</ol>
<pre><code class="language-java">webview.addJavascriptInterface(new WebAppInterface(), &quot;Android&quot;);
</code></pre>
<h2 id="android调用js方法">Android调用js方法</h2>
<p>loadUrl方法调用js</p>
<pre><code class="language-java">webview.loadUrl(javascript:if(window.setUrl)setUrl{'参数'});
//setUrl 是js的方法名
</code></pre>
<h2 id="js调用android方法">js调用Android方法</h2>
<pre><code class="language-javascript">var url = window.Android.getUrl();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DJI-SDK Hotpoint Mission 实现思路]]></title>
        <id>https://yugoal.github.io/post/dji-sdk-hotpoint-mission-shi-xian-si-lu/</id>
        <link href="https://yugoal.github.io/post/dji-sdk-hotpoint-mission-shi-xian-si-lu/">
        </link>
        <updated>2021-03-03T02:54:50.000Z</updated>
        <content type="html"><![CDATA[<p><em>功能概念可以看看这篇文章</em><a href="https://www.yuque.com/kiwi/ios/ir62ri"><em>https://www.yuque.com/kiwi/ios/ir62ri</em></a>_ 描述的比较详细。_</p>
<h2 id="1时间轴实现绕点飞行拍照">1.时间轴实现绕点飞行拍照</h2>
<p>可直接参考dji demo里面的时间轴做法添加Hotpoint任务和拍照任务执行。<br>
缺点：兼容性不高，部分机型不适合。</p>
<h2 id="2hotpoint实现绕点飞行定时器实现拍照和录像">2.Hotpoint实现绕点飞行，定时器实现拍照和录像</h2>
<ol>
<li>使用Hotpoint 实现无人机的绕点飞行。</li>
<li>Hotpoint开始执行时启动定时器定时拍照。</li>
</ol>
<pre><code class="language-java">//1.创建hotpointmission
HotpointMission hotpointMission = new HotpointMission();
hotpointMission.setAltitude(100);
//....填写各项参数
//2.创建执行器
HotpointMissionOperator hotpointMissionOperator = new HotpointMissionOperator;
hotpointMissionOperator.addListener(new HotpointMissionOperatorListener() {
            @Override
            public void onExecutionUpdate(HotpointMissionEvent hotpointMissionEvent) {
                if (hotpointMissionEvent.getCurrentState().getName().equals(&quot;EXECUTING&quot;)) {
                    if (timer == null) {
                        timer = new RxTimer();
                        timer.startTimmer(hotPointBaseSetFragment.getSecond(), new RxTimer.RxTimerNextListener() {
                            @Override
                            public void onTimerNext(long number) {
                                Log.d(TAG, &quot;onTimerNext: &quot; + number);
                                if (hotPointBaseSetFragment.isRecode()) {
                                    //视频
                                    if (!isRecode) {
                                        LxApplication.getProductInstance().getCamera().setMode(SettingsDefinitions.CameraMode.RECORD_VIDEO, new CommonCallbacks.CompletionCallback() {
                                            @Override
                                            public void onResult(DJIError djiError) {
                                                if (null == djiError) {
                                                    LxApplication.getProductInstance().getCamera().startRecordVideo(new CommonCallbacks.CompletionCallback() {
                                                        @Override
                                                        public void onResult(DJIError djiError) {
                                                            if (null == djiError) {
                                                                isRecode = true;
                                                            } else {
                                                                Log.d(TAG, &quot;onResult: &quot; + djiError.getDescription());
                                                            }
                                                        }
                                                    });
                                                }
                                            }
                                        });
                                    }
                                } else {
                                    LxApplication.getProductInstance().getCamera().setMode(SettingsDefinitions.CameraMode.SHOOT_PHOTO, new CommonCallbacks.CompletionCallback() {
                                        @Override
                                        public void onResult(DJIError djiError) {
                                            if (null == djiError) {
                                                //拍照
                                                LxApplication.getProductInstance()
                                                        .getCamera().startShootPhoto(new CommonCallbacks.CompletionCallback() {
                                                    @Override
                                                    public void onResult(DJIError djiError) {

                                                    }
                                                });
                                            }
                                        }
                                    });
                                }
                            }
                        });
                    }
                }
                Log.d(TAG, &quot;onExecutionUpdate: &quot; + hotpointMissionEvent.getCurrentState().getName());
            }

            @Override
            public void onExecutionStart() {
                Log.d(TAG, &quot;onExecutionStart: &quot;);

            }

            @Override
            public void onExecutionFinish(DJIError djiError) {
                Log.d(TAG, &quot;onExecutionFinish: &quot; + djiError.getDescription());
            }
        });
        hotpointMissionOperator.startMission(hotpointMission, djiError -&gt; Log.d(TAG, &quot;onResult: &quot; + djiError.getDescription()));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ—Android客户端]]></title>
        <id>https://yugoal.github.io/post/rabbitmq-android-ke-hu-duan/</id>
        <link href="https://yugoal.github.io/post/rabbitmq-android-ke-hu-duan/">
        </link>
        <updated>2017-09-10T02:56:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="工作原理">工作原理</h2>
<p><a href="http://rabbitmq.mr-ping.com/description.html">RabbitMQ-中文文档</a><br>
<a href="https://www.rabbitmq.com/getstarted.html">RabbitMQ-官网</a><br>
上面的网站详细的描述了整个框架。建议没接触过RabbitMQ的同学先看看。了解原理后，就直接看下面的代码吧。</p>
<h2 id="生产者">生产者</h2>
<p>由于后台缘故，这里不需要exchange。想要看完整的流程的同学可以去看<a href="http://www.jianshu.com/p/e138a79d726c">这篇文章</a>。<br>
注意要在子线程中运行</p>
<pre><code>ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(HOST);//ip地址
        factory.setPort(PORT);//端口号
        factory.setUsername(&quot;test&quot;);
        factory.setPassword(&quot;test&quot;);
        //创建一个新连接
        Connection connection = factory.newConnection();
        //创建一个通道
        Channel channel = connection.createChannel();
        //声明一个队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        //发送消息
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(&quot;UTF-8&quot;));
        //消息发送完成后，需要关闭通道和连接
        channel.close();
        connection.close();
</code></pre>
<h2 id="消费者">消费者</h2>
<pre><code>ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(HOST);
        factory.setPort(PORT);
        factory.setUsername(&quot;test&quot;);
        factory.setPassword(&quot;test&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        //声明一个队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        Consumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;RecvLogsTopic1 [x] Received '&quot; + envelope.getRoutingKey() + &quot;':'&quot; + message + &quot;'&quot;);
            }
        };
        channel.basicConsume(QUEUE_NAME, true, consumer);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebViewjavascriptBridge 关于setWebViewClient 拦截后JS失效的问题]]></title>
        <id>https://yugoal.github.io/post/webviewjavascriptbridge-guan-yu-setwebviewclient-lan-jie-hou-js-shi-xiao-de-wen-ti/</id>
        <link href="https://yugoal.github.io/post/webviewjavascriptbridge-guan-yu-setwebviewclient-lan-jie-hou-js-shi-xiao-de-wen-ti/">
        </link>
        <updated>2017-03-01T02:57:18.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.添加请求头</strong></p>
<pre><code>Map&lt;String,String&gt; extraHeaders = new HashMap&lt;String, String&gt;();
extraHeaders.put(&quot;auth&quot;, referer);
extraHeaders.put(&quot;imei&quot;, tm.getDeviceId());
extraHeaders.put(&quot;cookie&quot;,&quot;JSESSIONID=&quot;+jsid);

mWebview.loadurl(url,extraHeaders);

url:加载的H5链接
extraHeaders: 请求头数据
</code></pre>
<p><strong>2.关于setWebViewClient 拦截后JS失效的问题</strong></p>
<p>因为webViewjavascriptBridge 初始化时会默认设置一个BridgeWebViewClient，所以当我们在代码中再次设置WebViewClient会覆盖掉之前的方法，这样会导致JS失效。<br>
解决方法：</p>
<pre><code>@Override
public boolean shouldOverrideUrlLoading(WebView view, String url) {
  try{
    url = URLDecoder.decode(url,&quot;UTF-8&quot;);
  }catch(UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  if(url.startsWith(BridgeUtil.YY_RETURN_DATA)) {//如果是返回数据
    webView.handlerReturnData(url);
    return true;
  }else if(url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) {//
    webView.flushMessageQueue();
  return true;
  }else{
    view.loadUrl(url,webView.getMap());//重写最后一步
    return super.shouldOverrideUrlLoading(view, url);
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信支付、支付宝支付]]></title>
        <id>https://yugoal.github.io/post/wei-xin-zhi-fu-zhi-fu-bao-zhi-fu/</id>
        <link href="https://yugoal.github.io/post/wei-xin-zhi-fu-zhi-fu-bao-zhi-fu/">
        </link>
        <updated>2016-08-03T02:53:31.000Z</updated>
        <content type="html"><![CDATA[<p>##前言<br>
最近公司App需要做微信支付这一块，然后就是被微信支付各种虐。所以觉得有必要把这痛苦的经历记录下来。<br>
####一.发送商品订单给服务器，然后从服务器获取支付请求参数<br>
<em>1.首先注册，其中api为IWXAPI的实例。</em></p>
<pre><code>api=WXAPIFactory.createWXAPI(context,APP_ID,false);
api.registerApp(APP_ID);
</code></pre>
<p><em>2.从服务端拿到必要参数后，调支付即可，其中params是自定义的用来保存从服务端获取的发起支付请求所需要的参数对象。</em></p>
<pre><code>if(api!=null){
if(isWXAppInstalled()){
PayReqreq=newPayReq();
req.appId=APP_ID;
req.partnerId=params.getPartnerId();
req.prepayId=params.getPrepayId();
req.packageValue=params.getPackageValue();
req.nonceStr=params.getNonceStr();
req.timeStamp=params.getTimeStamp();
req.sign=params.getSign();

api.sendReq(req);
}
}
</code></pre>
<p><em>3.WXPayEntryActivity支付回调界面</em></p>
<pre><code>public class WXPayEntryActivity extends Activity implements IWXAPIEventHandler {
	private static final String TAG = &quot;WXPayEntryActivity&quot;;

	private IWXAPI api;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.pay_result);
		api = WXAPIFactory.createWXAPI(this, Constants.APP_ID);
		api.handleIntent(getIntent(), this);
	}

	@Override
	protected void onNewIntent(Intent intent) {
		super.onNewIntent(intent);
		setIntent(intent);
		api.handleIntent(intent, this);
	}

	@Override
	public void onReq(BaseReq req) {
	}

	@Override
	public void onResp(BaseResp resp) {
		Log.d(TAG, &quot;onPayFinish, errCode = &quot; + resp.errCode);

		if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) {
			if(resp.errCode == 0){
				MyToast.showToast(this,&quot;支付成功&quot;);
			}else if(resp.errCode == -2){
				MyToast.showToast(this,&quot;支付取消&quot;);
			}
			finish();
		}
	}
}
</code></pre>
<p>####二.App获取预支付订单，然后发送请求<br>
<em>1.预支付请求数据</em></p>
<pre><code>/**
     * 预支付请求数据
     *
     * @return
     */
    private String genProductArgs() {
        StringBuffer xml = new StringBuffer();

        try {
            String nonceStr = genNonceStr();
            xml.append(&quot;&lt;/xml&gt;&quot;);
            List&lt;NameValuePair&gt; packageParams = new LinkedList&lt;NameValuePair&gt;();
            packageParams.add(new BasicNameValuePair(&quot;appid&quot;, Constants.APP_ID));
            packageParams.add(new BasicNameValuePair(&quot;body&quot;, xiaoqu_name+&quot;--&quot;+pay_name));
            packageParams.add(new BasicNameValuePair(&quot;mch_id&quot;, Constants.MCH_ID));
            packageParams.add(new BasicNameValuePair(&quot;nonce_str&quot;, nonceStr));
            packageParams.add(new BasicNameValuePair(&quot;notify_url&quot;, &quot;http://weixin.qq.com&quot;));
            packageParams.add(new BasicNameValuePair(&quot;out_trade_no&quot;, genOutTradNo()));
            packageParams.add(new BasicNameValuePair(&quot;spbill_create_ip&quot;, &quot;127.0.0.1&quot;));
            packageParams.add(new BasicNameValuePair(&quot;total_fee&quot;, pay_num));
            packageParams.add(new BasicNameValuePair(&quot;trade_type&quot;, &quot;APP&quot;));

            String sign = genPackageSign(packageParams);
            packageParams.add(new BasicNameValuePair(&quot;sign&quot;, sign));

            String xmlstring = toXml(packageParams);
            return new String(xmlstring.toString().getBytes(), &quot;ISO8859-1&quot;);

        } catch (Exception e) {
            Log.e(TAG, &quot;genProductArgs fail, ex = &quot; + e.getMessage());
            return null;
        }
    }
</code></pre>
<p><em>2.获取预支付订单</em></p>
<pre><code>/**
     * 异步获取预支付订单 prepay_id
     */
    private class GetPrepayIdTask extends AsyncTask&lt;Void, Void, Map&lt;String, String&gt;&gt; {

        private ProgressDialog dialog;


        @Override
        protected void onPreExecute() {
            dialog = ProgressDialog.show(PayOrderActivity.this, &quot;&quot;, getString(R.string.getting_prepayid));
        }

        @Override
        protected void onPostExecute(Map&lt;String, String&gt; result) {
            if (dialog != null) {
                dialog.dismiss();
            }
            sb.append(&quot;prepay_id\n&quot; + result.get(&quot;prepay_id&quot;) + &quot;\n\n&quot;);
            resultunifiedorder = result;
        
            //获取支付请求数据，发起支付请求
            genPayReq();
        }

        @Override
        protected void onCancelled() {
            super.onCancelled();
        }

        @Override
        protected Map&lt;String, String&gt; doInBackground(Void... params) {

            //获取预支付订单
            String url = String.format(&quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;);
            String entity = genProductArgs();

            Log.e(&quot;entity&quot;, entity);

            byte[] buf = Util.httpPost(url, entity);

            String content = new String(buf);
            Log.e(&quot;content&quot;, content);
            Map&lt;String, String&gt; xml = decodeXml(content);

            return xml;
        }
    }
</code></pre>
<p><em>3.全部代码</em></p>
<pre><code>public class PayOrderActivity extends BaseActivity {
    private static final String TAG = &quot;PayOrderActivity&quot;;

    @Bind(R.id.button)
    Button button;

    PayReq req;
    final IWXAPI msgApi = WXAPIFactory.createWXAPI(this, null);
    //	TextView show;
    Map&lt;String, String&gt; resultunifiedorder;
    StringBuffer sb;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_pay_order);
        ButterKnife.bind(this);
       
        req = new PayReq();
        sb = new StringBuffer();

        msgApi.registerApp(Constants.APP_ID);


    }

    @OnClick({R.id.button})
    public void onClick(View view) {
        switch (view.getId()) {
            case R.id.button:
                if(pay_id == null||pay_id.length()==0){
                    MyToast.showToast(PayOrderActivity.this,&quot;请选择缴费类型&quot;);
                }else {
                    GetPrepayIdTask getPrepayId = new GetPrepayIdTask();
                    getPrepayId.execute();
                }
                break;
        }
    }

    /**
     * 异步获取预支付订单 prepay_id
     */
    private class GetPrepayIdTask extends AsyncTask&lt;Void, Void, Map&lt;String, String&gt;&gt; {

        private ProgressDialog dialog;


        @Override
        protected void onPreExecute() {
            dialog = ProgressDialog.show(PayOrderActivity.this, &quot;&quot;, getString(R.string.getting_prepayid));
        }

        @Override
        protected void onPostExecute(Map&lt;String, String&gt; result) {
            if (dialog != null) {
                dialog.dismiss();
            }
            sb.append(&quot;prepay_id\n&quot; + result.get(&quot;prepay_id&quot;) + &quot;\n\n&quot;);
//			show.setText(sb.toString());

            resultunifiedorder = result;
            genPayReq();
        }

        @Override
        protected void onCancelled() {
            super.onCancelled();
        }

        @Override
        protected Map&lt;String, String&gt; doInBackground(Void... params) {

            //获取预支付订单
            String url = String.format(&quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;);
            String entity = genProductArgs();

            Log.e(&quot;entity&quot;, entity);

            byte[] buf = Util.httpPost(url, entity);

            String content = new String(buf);
            Log.e(&quot;content&quot;, content);
            Map&lt;String, String&gt; xml = decodeXml(content);

            return xml;
        }
    }


    /**
     * 获取支付请求数据，发起支付请求
     */
    private void genPayReq() {
        req.appId = Constants.APP_ID;
        req.partnerId = Constants.MCH_ID;
        req.prepayId = resultunifiedorder.get(&quot;prepay_id&quot;);
        req.packageValue = &quot;Sign=WXPay&quot;;
        req.nonceStr = genNonceStr();
        req.timeStamp = String.valueOf(genTimeStamp());


        List&lt;NameValuePair&gt; signParams = new LinkedList&lt;NameValuePair&gt;();
        signParams.add(new BasicNameValuePair(&quot;appid&quot;, req.appId));
        signParams.add(new BasicNameValuePair(&quot;noncestr&quot;, req.nonceStr));
        signParams.add(new BasicNameValuePair(&quot;package&quot;, req.packageValue));
        signParams.add(new BasicNameValuePair(&quot;partnerid&quot;, req.partnerId));
        signParams.add(new BasicNameValuePair(&quot;prepayid&quot;, req.prepayId));
        signParams.add(new BasicNameValuePair(&quot;timestamp&quot;, req.timeStamp));

        req.sign = genAppSign(signParams);

        sb.append(&quot;sign\n&quot; + req.sign + &quot;\n\n&quot;);
        //SPUtil.put(this, &quot;uid&quot;, req.prepayId);
//		show.setText(sb.toString());
        sendPayReq();
        Log.e(&quot;PayReq&quot;, signParams.toString());
    }

    /**
     * 支付请求签名
     *
     * @param params
     * @return
     */
    private String genAppSign(List&lt;NameValuePair&gt; params) {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i &lt; params.size(); i++) {
            sb.append(params.get(i).getName());
            sb.append('=');
            sb.append(params.get(i).getValue());
            sb.append('&amp;');
        }
        sb.append(&quot;key=&quot;);
        sb.append(Constants.API_KEY);

        this.sb.append(&quot;sign str\n&quot; + sb.toString() + &quot;\n\n&quot;);
        String appSign = MD5.getMessageDigest(sb.toString().getBytes()).toUpperCase();
        Log.e(&quot;orion&quot;, appSign);
        return appSign;
    }

    /**
     * 预支付请求数据
     *
     * @return
     */
    private String genProductArgs() {
        StringBuffer xml = new StringBuffer();

        try {
            String nonceStr = genNonceStr();


            xml.append(&quot;&lt;/xml&gt;&quot;);
            List&lt;NameValuePair&gt; packageParams = new LinkedList&lt;NameValuePair&gt;();
            packageParams.add(new BasicNameValuePair(&quot;appid&quot;, Constants.APP_ID));
            packageParams.add(new BasicNameValuePair(&quot;body&quot;, &quot;测试商品&quot;));
            packageParams.add(new BasicNameValuePair(&quot;mch_id&quot;, Constants.MCH_ID));
            packageParams.add(new BasicNameValuePair(&quot;nonce_str&quot;, nonceStr));
            packageParams.add(new BasicNameValuePair(&quot;notify_url&quot;, &quot;http://weixin.qq.com&quot;));
            packageParams.add(new BasicNameValuePair(&quot;out_trade_no&quot;, genOutTradNo()));
            packageParams.add(new BasicNameValuePair(&quot;spbill_create_ip&quot;, &quot;127.0.0.1&quot;));
            packageParams.add(new BasicNameValuePair(&quot;total_fee&quot;, pay_num));
            packageParams.add(new BasicNameValuePair(&quot;trade_type&quot;, &quot;APP&quot;));


            String sign = genPackageSign(packageParams);
            packageParams.add(new BasicNameValuePair(&quot;sign&quot;, sign));


            String xmlstring = toXml(packageParams);
            return new String(xmlstring.toString().getBytes(), &quot;ISO8859-1&quot;);

        } catch (Exception e) {
            Log.e(TAG, &quot;genProductArgs fail, ex = &quot; + e.getMessage());
            return null;
        }
    }

    /**
     * 随机字符串
     *
     * @return
     */
    private String genNonceStr() {
        Random random = new Random();
        return MD5.getMessageDigest(String.valueOf(random.nextInt(10000)).getBytes());
    }

    /**
     * 订单时间
     *
     * @return
     */
    private long genTimeStamp() {
        return System.currentTimeMillis() / 1000;
    }


    /**
     * 随机产生商户订单号
     *
     * @return
     */
    private String genOutTradNo() {
        Random random = new Random();
        u_id = MD5.getMessageDigest(String.valueOf(random.nextInt(10000)).getBytes());
        return u_id;
    }

    /**
     * 生成签名 获取预支付订单签名
     */
    private String genPackageSign(List&lt;NameValuePair&gt; params) {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i &lt; params.size(); i++) {
            sb.append(params.get(i).getName());
            sb.append('=');
            sb.append(params.get(i).getValue());
            sb.append('&amp;');
        }
        sb.append(&quot;key=&quot;);
        sb.append(Constants.API_KEY);


        String packageSign = MD5.getMessageDigest(sb.toString().getBytes()).toUpperCase();
        Log.e(&quot;orion&quot;, packageSign);
        return packageSign;
    }

    /**
     * 参数转xml
     *
     * @param params
     * @return
     */
    private String toXml(List&lt;NameValuePair&gt; params) {
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;&lt;xml&gt;&quot;);
        for (int i = 0; i &lt; params.size(); i++) {
            sb.append(&quot;&lt;&quot; + params.get(i).getName() + &quot;&gt;&quot;);


            sb.append(params.get(i).getValue());
            sb.append(&quot;&lt;/&quot; + params.get(i).getName() + &quot;&gt;&quot;);
        }
        sb.append(&quot;&lt;/xml&gt;&quot;);

        Log.e(&quot;orion&quot;, sb.toString());
        return sb.toString();
    }

    /**
     * xml 转Map
     *
     * @param content
     * @return
     */
    public Map&lt;String, String&gt; decodeXml(String content) {

        try {
            Map&lt;String, String&gt; xml = new HashMap&lt;String, String&gt;();
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(new StringReader(content));
            int event = parser.getEventType();
            while (event != XmlPullParser.END_DOCUMENT) {

                String nodeName = parser.getName();
                switch (event) {
                    case XmlPullParser.START_DOCUMENT:

                        break;
                    case XmlPullParser.START_TAG:

                        if (&quot;xml&quot;.equals(nodeName) == false) {
                            //实例化student对象
                            xml.put(nodeName, parser.nextText());
                        }
                        break;
                    case XmlPullParser.END_TAG:
                        break;
                }
                event = parser.next();
            }

            return xml;
        } catch (Exception e) {
            Log.e(&quot;orion&quot;, e.toString());
        }
        return null;

    }

    /**
     * 发起支付请求
     */
    private void sendPayReq() {
        msgApi.registerApp(Constants.APP_ID);
        msgApi.sendReq(req);
    }
}
</code></pre>
<p>##接下来就是踩坑</p>
<blockquote>
<p>1.微信支付官方demo提供的接口，每个微信账号只能调用一次，再次调用时支付返回code值为-1（貌似是因为签名的原因）</p>
</blockquote>
<h2 id="1接入支付宝">1.接入支付宝</h2>
<h3 id="接入前准备">接入前准备</h3>
<ul>
<li>商户需要进行审核签约</li>
<li>密钥管理（生成公私钥）</li>
</ul>
<h3 id="正式接入">正式接入</h3>
<p><strong>服务端</strong><br>
私钥必须放在服务端，签名过程必须放在服务端。</p>
<p><strong>客户端（Android）</strong></p>
<ol>
<li>根据用户选择商品请求服务端获取订单和签名，</li>
<li>根据服务端返回订单和签名调起支付宝App支付，并对支付返回结果做处理。</li>
</ol>
<h2 id="2android-集成并调用支付宝">2.Android 集成并调用支付宝</h2>
<ul>
<li>. 添加jar包</li>
<li>. gradle中添加依赖</li>
</ul>
<hr>
<pre><code>PayTask payTask = new PayTask(AboutUsActivity.this);
	Map&lt;String, String&gt; result = payTask.payV2(orderInfo, true);
</code></pre>
<pre><code>orderInfo ：服务端返回的订单信息。
</code></pre>
<h2 id="3返回结果处理全部代码">3.返回结果处理（全部代码）</h2>
<pre><code>/**
 * 支付宝
 * @param strURL
 */
private void aliPay(String strURL) {
    Observable.create(new ObservableOnSubscribe&lt;Object&gt;() {
        @Override
        public void subscribe(@NonNull ObservableEmitter&lt;Object&gt; e) throws Exception {
            String orderInfo = OkClient.get(strURL, new JSONObject());//获取订单信息
            orderInfo = orderInfo.replace(&quot;amp;&quot;, &quot;&quot;);//后台PHP，返回的所有&amp;参数都变成&amp;amp，所有需要替换。
            PayTask payTask = new PayTask(AboutUsActivity.this);
            Map&lt;String, String&gt; result = payTask.payV2(orderInfo, true);
            e.onNext(result);
        }
    }).compose(RxUtil.activityLifecycle(this))
            .compose(RxUtil.io())
            .subscribe(new Consumer&lt;Object&gt;() {
                @Override
                public void accept(@NonNull Object o) throws Exception {
                    closeProgressDialog();
                    PayResult payResult = new PayResult((Map&lt;String, String&gt;) o);
                    /**
                     对于支付结果，请商户依赖服务端的异步通知结果。同步通知结果，仅作为支付结束的通知。
                     */
                    String resultInfo = payResult.getResult();// 同步返回需要验证的信息
                    String resultStatus = payResult.getResultStatus();
                    // 判断resultStatus 为9000则代表支付成功
                    if (TextUtils.equals(resultStatus, AliPay.PAY_OK)) {//---------&gt;支付成功
                        finish();
                    } else if (TextUtils.equals(resultStatus, AliPay.PAY_FAIL)) {//---------&gt;支付失败
                        // 该笔订单真实的支付结果，需要依赖服务端的异步通知。
                        ToastUtils.showToast(payResult.getMemo());
                    } else if (TextUtils.equals(resultStatus, AliPay.PAY_CANCEL)) {//---------&gt;交易取消
                        ToastUtils.showToast(payResult.getMemo());
                    } else if (TextUtils.equals(resultStatus, AliPay.PAY_NET_ERROR)) {//----------&gt;网络出现错误
                        ToastUtils.showToast(payResult.getMemo());
                    } else if (TextUtils.equals(resultStatus, AliPay.PAY_REPEAT)) {//------&gt;交易重复
                    }
                }
            });
}
</code></pre>
<h2 id="4回调类">4.回调类</h2>
<pre><code>/**
* 支付宝回调code值
*/

public class AliPay {

	public static final String PAY_OK = &quot;9000&quot;;//支付宝支付成功
	public static final String PAY_PROCESSING_UNKNOWN = &quot;8000&quot;;//正在处理中，支付结果未知（有可能已经支付成功），请查询商户订单列表中订单的支付状态
	public static final String PAY_FAIL = &quot;4000&quot;;//支付宝支付失败
	public static final String PAY_REPEAT = &quot;5000&quot;;//支付宝支付重复请求
	public static final String PAY_CANCEL = &quot;6001&quot;;//用户中途取消
	public static final String PAY_NET_ERROR = &quot;6002&quot;;//网络连接出错
	public static final String PAY_UNKNOWN = &quot;6004&quot;;//支付结果未知（有可能已经支付成功），请查询商户订单列表中订单的支付状态
}


/**
* 支付宝回调
*/

public class PayResult {
	private String resultStatus;
	private String result;
	private String memo;

	public PayResult(Map&lt;String, String&gt; rawResult) {
	    if (rawResult == null) {
	        return;
	    }

	    for (String key : rawResult.keySet()) {
	        if (TextUtils.equals(key, &quot;resultStatus&quot;)) {
	            resultStatus = rawResult.get(key);
	        } else if (TextUtils.equals(key, &quot;result&quot;)) {
	            result = rawResult.get(key);
	        } else if (TextUtils.equals(key, &quot;memo&quot;)) {
	            memo = rawResult.get(key);
	        }
	    }
	}

	@Override
	public String toString() {
	    return &quot;resultStatus={&quot; + resultStatus + &quot;};memo={&quot; + memo
            + &quot;};result={&quot; + result + &quot;}&quot;;
	}

	/**
	 * @return the resultStatus
	 */
	public String getResultStatus() {
	    return resultStatus;
	}

	/**
	 * @return the memo
	 */
	public String getMemo() {
	    return memo;
	}

	/**
	 * @return the result
	 */
	public String getResult() {
	    return result;
	}
}
</code></pre>
]]></content>
    </entry>
</feed>